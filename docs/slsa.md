# SLSA Compliance & Supply‑Chain Security

## Purpose

This document explains how the **CSV Ingestion & Processing Engine** CI/CD pipeline aligns with the **SLSA (Supply‑chain Levels for Software Artifacts)** framework. It is written for **security reviewers, auditors, and senior engineers** to understand the guarantees provided by the pipeline and its current compliance level.

The goal is to provide **verifiable evidence**, not marketing claims.

---

## What Is SLSA

SLSA (Supply‑chain Levels for Software Artifacts) is a security framework that defines **progressive levels of assurance** against supply‑chain attacks.

It focuses on four core areas:

1. **Source integrity** – where code comes from
2. **Build integrity** – how artifacts are produced
3. **Provenance** – verifiable metadata about the build
4. **Artifact integrity** – protection against tampering

This project targets **SLSA Level 3**.

---

## Current Target: SLSA Level 3

### Why Level 3

SLSA Level 3 provides strong guarantees while remaining realistic for modern CI systems:

* Builds are **fully automated**
* Builds run on **trusted, ephemeral infrastructure**
* Provenance is **generated and cryptographically signed**
* Artifacts are **immutable and verifiable**

Higher levels (SLSA 4) require hermetic builds and reproducibility guarantees that are intentionally out of scope for this project.

---

## SLSA Requirements Mapping

### 1. Source Integrity

**Requirement:** Source must be version‑controlled, immutable, and auditable.

**Implementation:**

* GitHub repository with protected `main` branch
* All changes go through Pull Requests
* CI workflows triggered only from GitHub events
* Full commit history preserved (`fetch-depth: 0`)

**Result:**

✔ Source is tamper‑resistant and auditable

---

### 2. Build Platform Security

**Requirement:** Builds must run on a trusted platform with isolation between runs.

**Implementation:**

* GitHub Actions hosted runners (`ubuntu-latest`)
* Ephemeral VMs per job execution
* No self‑hosted runners
* Short‑lived OIDC tokens for identity

**Result:**

✔ Builds run in isolated, trusted environments

---

### 3. Scripted, Automated Builds

**Requirement:** Build steps must be fully defined in code.

**Implementation:**

* All build logic is defined in YAML workflows
* No manual build or release steps
* Deterministic Docker builds using pinned actions

**Result:**

✔ Builds are repeatable and non‑interactive

---

### 4. Dependency & Code Security (Shift‑Left)

**Requirement:** Early detection of vulnerabilities and malicious code.

**Implementation:**

* Secret scanning: **Gitleaks**
* SAST: **Bandit**, **Pylint**
* SCA: **Snyk** (dependencies)
* Container scanning: **Trivy**
* Dockerfile linting: **Hadolint**

**Result:**

✔ Security issues are detected before artifacts are released

---

### 5. Artifact Integrity (Immutable Artifacts)

**Requirement:** Artifacts must not be mutable after creation.

**Implementation:**

* Docker images are referenced and signed by **digest (`@sha256`)**, not tags
* Vulnerability scanning occurs **before signing**
* Only scanned artifacts are signed

**Result:**

✔ Artifacts are immutable and tamper‑evident

---

### 6. Cryptographic Signing (Keyless)

**Requirement:** Artifacts must be cryptographically signed.

**Implementation:**

* **Cosign keyless signing** using GitHub OIDC
* No long‑lived signing keys
* Identity bound to GitHub repository and workflow

**Verification Example:**

```bash
cosign verify \
  index.docker.io/<org>/<image>@sha256:<digest> \
  --certificate-oidc-issuer https://token.actions.githubusercontent.com
```

**Result:**

✔ Artifact authenticity can be independently verified

---

### 7. Provenance Generation (SLSA Provenance)

**Requirement:** Provenance must be generated by the build system and be verifiable.

**Implementation:**

* GitHub native provenance via `actions/attest-build-provenance`
* Provenance is:

  * Bound to the **artifact digest**
  * Signed using GitHub OIDC
  * Uploaded to the container registry

**Result:**

✔ Consumers can verify *who built what, when, and how*

---

### 8. SBOM Generation & Attestation

**Requirement:** Transparency into artifact contents.

**Implementation:**

* SBOM generated using **Anchore SBOM Action**
* SPDX‑JSON format
* SBOM is attested using Cosign

**Result:**

✔ Downstream systems can audit dependencies

---

## What This Pipeline Prevents

This design mitigates common supply‑chain attacks:

* ❌ Tampering with images after build
* ❌ Replacing tagged images silently
* ❌ Injecting code outside of version control
* ❌ Using stolen signing keys
* ❌ Publishing unscanned artifacts

---

## Known Limitations (Intentional)

The following are **explicitly out of scope**:

* Hermetic builds
* Bit‑for‑bit reproducibility
* Trusted external dependency mirrors

These are required for **SLSA Level 4**, not Level 3.

---

## Summary for Auditors

| Area                      | Status |
| ------------------------- | ------ |
| Version‑controlled source | ✅      |
| Automated CI builds       | ✅      |
| Trusted build platform    | ✅      |
| Digest‑pinned artifacts   | ✅      |
| Keyless signing           | ✅      |
| SBOM generation           | ✅      |
| Provenance attestation    | ✅      |
| SLSA Level 3 alignment    | ✅      |

---

## How to Verify (Consumer Perspective)

1. Pull image by digest
2. Verify Cosign signature
3. Verify SLSA provenance
4. Inspect SBOM

This ensures the artifact you deploy is **exactly what CI produced**.

---

## Final Note

SLSA compliance is not a checkbox. It is a **system property**.

This pipeline prioritizes **verifiability, auditability, and trust**, not convenience.
